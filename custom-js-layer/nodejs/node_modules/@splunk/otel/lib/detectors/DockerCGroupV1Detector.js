"use strict";
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.dockerCGroupV1Detector = exports.DockerCGroupV1Detector = void 0;
/* This is based on a detector from OTel https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-resources/src/detectors/
 We're copying this code and changing the implementation to a synchronous one from async. This is required for our distribution to not incur ~1 second of overhead
 when setting up the tracing pipeline. This is a temporary solution until we can agree upon and implement a solution upstream.
*/
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const resources_1 = require("@opentelemetry/resources");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const fs = require("fs");
const os_1 = require("os");
const api_1 = require("@opentelemetry/api");
const isValidBase16String = (hexString) => {
    for (let ch = 0; ch < hexString.length; ch++) {
        const code = hexString.charCodeAt(ch);
        if ((48 <= code && code <= 57) ||
            (97 <= code && code <= 102) ||
            (65 <= code && code <= 70)) {
            continue;
        }
        return false;
    }
    return true;
};
class DockerCGroupV1Detector {
    detect(_config) {
        if ((0, os_1.platform)() !== 'linux') {
            api_1.diag.debug('Docker CGROUP V1 Detector skipped: Not on linux');
            return resources_1.Resource.empty();
        }
        try {
            const containerId = this._getContainerId();
            return !containerId
                ? resources_1.Resource.empty()
                : new resources_1.Resource({
                    [semantic_conventions_1.SemanticResourceAttributes.CONTAINER_ID]: containerId,
                });
        }
        catch (e) {
            api_1.diag.info('Docker CGROUP V1 Detector did not identify running inside a supported docker container, no docker attributes will be added to resource: ', e);
            return resources_1.Resource.empty();
        }
    }
    _getContainerId() {
        try {
            const rawData = fs.readFileSync('/proc/self/cgroup', 'utf8').trim();
            return this._parseFile(rawData);
        }
        catch (e) {
            if (e instanceof Error) {
                const errorMessage = e.message;
                api_1.diag.info('Docker CGROUP V1 Detector failed to read the Container ID: ', errorMessage);
            }
        }
        return null;
    }
    /*
      This is very likely has false positives since it does not check for the ID length,
      but is very robust in usually finding the right thing, and if not, finding some
      identifier for differentiating between containers.
      It also matches Java: https://github.com/open-telemetry/opentelemetry-java/commit/2cb461d4aef16f1ac1c5e67edc2fb41f90ed96a3#diff-ad68bc34d4da31a50709591d4b7735f88c008be7ed1fc325c6367dd9df033452
    */
    _parseFile(contents) {
        if (typeof contents !== 'string') {
            return null;
        }
        for (const line of contents.split('\n')) {
            const lastSlashIdx = line.lastIndexOf('/');
            if (lastSlashIdx < 0) {
                return null;
            }
            const lastSection = line.substring(lastSlashIdx + 1);
            let startIdx = lastSection.lastIndexOf('-');
            let endIdx = lastSection.lastIndexOf('.');
            startIdx = startIdx === -1 ? 0 : startIdx + 1;
            if (endIdx === -1) {
                endIdx = lastSection.length;
            }
            if (startIdx > endIdx) {
                return null;
            }
            const containerId = lastSection.substring(startIdx, endIdx);
            if (containerId && isValidBase16String(containerId)) {
                return containerId;
            }
        }
        return null;
    }
}
exports.DockerCGroupV1Detector = DockerCGroupV1Detector;
exports.dockerCGroupV1Detector = new DockerCGroupV1Detector();
//# sourceMappingURL=DockerCGroupV1Detector.js.map