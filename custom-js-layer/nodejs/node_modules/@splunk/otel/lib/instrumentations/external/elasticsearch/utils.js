"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultDbStatementSerializer = exports.onError = exports.onResponse = exports.getNetAttributes = exports.getPort = exports.normalizeArguments = exports.startSpan = exports.getIndexName = void 0;
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@opentelemetry/api");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getIndexName(params) {
    if (!(params === null || params === void 0 ? void 0 : params.index)) {
        return undefined;
    }
    if (typeof params.index === 'string') {
        return params.index;
    }
    if (Array.isArray(params.index)) {
        return params.index.join(',');
    }
}
exports.getIndexName = getIndexName;
function startSpan({ tracer, attributes }) {
    return tracer.startSpan('elasticsearch.request', {
        kind: api_1.SpanKind.CLIENT,
        attributes: Object.assign({ [semantic_conventions_1.SemanticAttributes.DB_SYSTEM]: 'elasticsearch' }, attributes),
    });
}
exports.startSpan = startSpan;
function normalizeArguments(params, options, callback) {
    // Copied normalizeArguments function from @elastic/elasticsearch
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }
    if (typeof params === 'function' || params === undefined || params === null) {
        callback = params;
        params = {};
        options = {};
    }
    return [params, options, callback];
}
exports.normalizeArguments = normalizeArguments;
function getPort(port, protocol) {
    if (port)
        return port;
    if (protocol === 'https:')
        return '443';
    if (protocol === 'http:')
        return '80';
    return '';
}
exports.getPort = getPort;
function getNetAttributes(url) {
    const { port, protocol, hostname } = new URL(url);
    return {
        [semantic_conventions_1.SemanticAttributes.NET_TRANSPORT]: 'IP.TCP',
        [semantic_conventions_1.SemanticAttributes.NET_PEER_NAME]: hostname,
        [semantic_conventions_1.SemanticAttributes.NET_PEER_PORT]: getPort(port, protocol),
    };
}
exports.getNetAttributes = getNetAttributes;
function onResponse(span, result, responseHook) {
    span.setAttributes(Object.assign({}, getNetAttributes(result.meta.connection.url.toString())));
    span.setStatus({
        code: api_1.SpanStatusCode.OK,
    });
    if (responseHook) {
        (0, instrumentation_1.safeExecuteInTheMiddle)(() => responseHook(span, result), (e) => {
            if (e) {
                api_1.diag.error('elasticsearch instrumentation: responseHook error', e);
            }
        }, true);
    }
    span.end();
}
exports.onResponse = onResponse;
function onError(span, err) {
    span.recordException(err);
    span.setStatus({
        code: api_1.SpanStatusCode.ERROR,
        message: err.message,
    });
    span.end();
}
exports.onError = onError;
const defaultDbStatementSerializer = (operation, params, options) => JSON.stringify({ params, options });
exports.defaultDbStatementSerializer = defaultDbStatementSerializer;
//# sourceMappingURL=utils.js.map