"use strict";
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.stopTracing = exports.startTracing = exports.getLoadedInstrumentations = exports.isTracingContextManagerEnabled = void 0;
const assert_1 = require("assert");
const semver_1 = require("semver");
const api_1 = require("@opentelemetry/api");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const context_async_hooks_1 = require("@opentelemetry/context-async-hooks");
const graphql_1 = require("../instrumentations/graphql");
const http_1 = require("../instrumentations/http");
const logging_1 = require("../instrumentations/logging");
const options_1 = require("./options");
const redis_1 = require("../instrumentations/redis");
const utils_1 = require("../utils");
const profiling_1 = require("../profiling");
/**
 * We disallow calling `startTracing` twice because:
 * 1. This is very rarely the user intention;
 * 2. Causes unexpected applied configuration to OTel libs;
 * 3. There's no way to reliably clean up before applying new configuration.
 * However, having a mechanism to allow that in tests is useful even if it
 * leaks and is inperfect in terms of the end result.
 */
const allowDoubleStart = (0, utils_1.parseEnvBooleanString)((0, utils_1.getNonEmptyEnvVar)('TEST_ALLOW_DOUBLE_START'));
let isStarted = false;
let tracingContextManagerEnabled = false;
let _instrumentations = [];
let unregisterInstrumentations = null;
function isTracingContextManagerEnabled() {
    return tracingContextManagerEnabled;
}
exports.isTracingContextManagerEnabled = isTracingContextManagerEnabled;
function getLoadedInstrumentations() {
    return _instrumentations;
}
exports.getLoadedInstrumentations = getLoadedInstrumentations;
function setLoadedInstrumentations(instrumentations) {
    _instrumentations = [];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function storeInstrumentation(instrumentation) {
        if (typeof instrumentation['setMeterProvider'] === 'function') {
            _instrumentations.push(instrumentation);
        }
    }
    for (const option of instrumentations) {
        if (Array.isArray(option)) {
            for (const instrumentation of option) {
                storeInstrumentation(instrumentation);
            }
        }
        else {
            storeInstrumentation(option);
        }
    }
}
function startTracing(opts = {}) {
    (0, assert_1.strict)(!isStarted, 'Splunk APM already started');
    isStarted = true;
    (0, utils_1.assertNoExtraneousProperties)(opts, options_1.allowedTracingOptions);
    const options = (0, options_1._setDefaultOptions)(opts);
    // propagator
    api_1.propagation.setGlobalPropagator(options.propagatorFactory(options));
    // OpenTelemetry would log an error diagnostic when attempting to overwrite a global.
    // Once profiling has set its context manager, we should not attempt to overwrite it.
    if (!(0, profiling_1.isProfilingContextManagerSet)()) {
        const ContextManager = (0, semver_1.gte)(process.version, '14.8.0')
            ? context_async_hooks_1.AsyncLocalStorageContextManager
            : context_async_hooks_1.AsyncHooksContextManager;
        const contextManager = new ContextManager();
        contextManager.enable();
        api_1.context.setGlobalContextManager(contextManager);
        tracingContextManagerEnabled = true;
    }
    // Workaround for https://github.com/open-telemetry/opentelemetry-js/issues/3422
    const envTracesExporter = process.env.OTEL_TRACES_EXPORTER;
    if (envTracesExporter !== undefined) {
        process.env.OTEL_TRACES_EXPORTER = '';
    }
    const provider = new sdk_trace_node_1.NodeTracerProvider(options.tracerConfig);
    if (envTracesExporter !== undefined) {
        process.env.OTEL_TRACES_EXPORTER = envTracesExporter;
    }
    configureInstrumentations(options);
    // instrumentations
    unregisterInstrumentations = (0, instrumentation_1.registerInstrumentations)({
        tracerProvider: provider,
        instrumentations: options.instrumentations,
    });
    setLoadedInstrumentations(options.instrumentations);
    // processors
    let processors = options.spanProcessorFactory(options);
    if (!Array.isArray(processors)) {
        processors = [processors];
    }
    for (const i in processors) {
        provider.addSpanProcessor(processors[i]);
    }
    // register global provider
    api_1.trace.setGlobalTracerProvider(provider);
    return true;
}
exports.startTracing = startTracing;
async function stopTracing() {
    if (allowDoubleStart) {
        isStarted = false;
    }
    // in reality unregistering is not reliable because of the function pointers
    // floating around everywhere in the user code already and will lead to
    // unexpected consequences should it be done more than once. We enable it
    // mostly for tests.
    unregisterInstrumentations === null || unregisterInstrumentations === void 0 ? void 0 : unregisterInstrumentations();
    unregisterInstrumentations = null;
    const shutdownPromise = shutdownGlobalTracerProvider();
    api_1.propagation.disable();
    if (tracingContextManagerEnabled) {
        api_1.context.disable();
        tracingContextManagerEnabled = false;
    }
    api_1.trace.disable();
    return shutdownPromise;
}
exports.stopTracing = stopTracing;
function isShutDownable(tracerProvider) {
    return typeof tracerProvider.shutdown === 'function';
}
async function shutdownGlobalTracerProvider() {
    var _a;
    // `shutdown` is not in the interface of TracerProvider - not always implemented
    // Global TracerProvider isn't actually the set TracerProvider, but a proxy
    const globalProvider = api_1.trace.getTracerProvider();
    let reportedConstructor = globalProvider === null || globalProvider === void 0 ? void 0 : globalProvider.constructor;
    if (globalProvider instanceof api_1.ProxyTracerProvider) {
        const delegate = globalProvider.getDelegate();
        reportedConstructor = delegate === null || delegate === void 0 ? void 0 : delegate.constructor;
        if (isShutDownable(delegate)) {
            return delegate.shutdown().catch((e) => {
                api_1.diag.warn('OpenTelemetry: error shutting down tracer provider', e);
            });
        }
    }
    api_1.diag.warn(`Enabled TracerProvider(${(_a = reportedConstructor === null || reportedConstructor === void 0 ? void 0 : reportedConstructor.name) !== null && _a !== void 0 ? _a : reportedConstructor}) does not implement shutdown()`);
}
function configureInstrumentations(options) {
    for (const instrumentation of options.instrumentations) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const instr = instrumentation;
        switch (instr['instrumentationName']) {
            case '@opentelemetry/instrumentation-graphql':
                (0, graphql_1.configureGraphQlInstrumentation)(instr, options);
                break;
            case '@opentelemetry/instrumentation-http':
                (0, http_1.configureHttpInstrumentation)(instr, options);
                break;
            case '@opentelemetry/instrumentation-redis':
                (0, redis_1.configureRedisInstrumentation)(instr, options);
                break;
            case '@opentelemetry/instrumentation-bunyan':
                (0, logging_1.disableLogSending)(instr);
                (0, logging_1.configureLogInjection)(instr);
                break;
            case '@opentelemetry/instrumentation-pino':
            case '@opentelemetry/instrumentation-winston':
                (0, logging_1.configureLogInjection)(instr);
                break;
        }
    }
}
//# sourceMappingURL=index.js.map