"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPropagatorFactory = exports.defaultSpanProcessorFactory = exports.consoleSpanExporterFactory = exports.otlpSpanExporterFactory = exports._setDefaultOptions = exports.allowedTracingOptions = void 0;
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const util = require("util");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const propagator_b3_1 = require("@opentelemetry/propagator-b3");
const instrumentations_1 = require("../instrumentations");
const exporter_trace_otlp_proto_1 = require("@opentelemetry/exporter-trace-otlp-proto");
const resource_1 = require("../resource");
const utils_1 = require("../utils");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const SplunkBatchSpanProcessor_1 = require("./SplunkBatchSpanProcessor");
const resources_1 = require("@opentelemetry/resources");
exports.allowedTracingOptions = [
    'accessToken',
    'realm',
    'captureHttpRequestUriParams',
    'endpoint',
    'instrumentations',
    'propagatorFactory',
    'serverTimingEnabled',
    'serviceName',
    'spanExporterFactory',
    'spanProcessorFactory',
    'tracerConfig',
];
function _setDefaultOptions(options = {}) {
    var _a, _b;
    process.env.OTEL_SPAN_LINK_COUNT_LIMIT =
        (_a = (0, utils_1.getNonEmptyEnvVar)('OTEL_SPAN_LINK_COUNT_LIMIT')) !== null && _a !== void 0 ? _a : '1000';
    process.env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT =
        (_b = (0, utils_1.getNonEmptyEnvVar)('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT')) !== null && _b !== void 0 ? _b : '12000';
    options.accessToken =
        options.accessToken || (0, utils_1.getNonEmptyEnvVar)('SPLUNK_ACCESS_TOKEN') || '';
    options.realm = options.realm || (0, utils_1.getNonEmptyEnvVar)('SPLUNK_REALM');
    if (options.realm) {
        if (!options.accessToken) {
            throw new Error('Splunk realm is set, but access token is unset. To send traces to the Observability Cloud, both need to be set');
        }
    }
    if (options.serverTimingEnabled === undefined) {
        options.serverTimingEnabled = (0, utils_1.getEnvBoolean)('SPLUNK_TRACE_RESPONSE_HEADER_ENABLED', true);
    }
    const extraTracerConfig = options.tracerConfig || {};
    let resource = (0, resource_1.detect)();
    const serviceName = options.serviceName ||
        (0, utils_1.getNonEmptyEnvVar)('OTEL_SERVICE_NAME') ||
        resource.attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME];
    if (!serviceName) {
        api_1.diag.warn('service.name attribute is not set, your service is unnamed and will be difficult to identify. ' +
            'Set your service name using the OTEL_RESOURCE_ATTRIBUTES environment variable. ' +
            'E.g. OTEL_RESOURCE_ATTRIBUTES="service.name=<YOUR_SERVICE_NAME_HERE>"');
    }
    resource = resource.merge(new resources_1.Resource({
        [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: serviceName || (0, utils_1.defaultServiceName)(),
    }));
    const tracerConfig = Object.assign({ resource }, extraTracerConfig);
    const exporterTypes = getExporterTypes(options);
    // factories
    if (options.spanExporterFactory === undefined) {
        options.spanExporterFactory = resolveTraceExporters(exporterTypes);
    }
    options.spanProcessorFactory =
        options.spanProcessorFactory || defaultSpanProcessorFactory;
    options.propagatorFactory =
        options.propagatorFactory || defaultPropagatorFactory;
    // instrumentations
    if (options.instrumentations === undefined) {
        options.instrumentations = (0, instrumentations_1.getInstrumentations)();
    }
    if (options.instrumentations.length === 0) {
        api_1.diag.warn('No instrumentations set to be loaded. Install an instrumentation package to enable auto-instrumentation.');
    }
    if (options.captureHttpRequestUriParams === undefined) {
        options.captureHttpRequestUriParams = [];
    }
    return {
        realm: options.realm,
        endpoint: options.endpoint,
        serviceName: String(resource.attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]),
        accessToken: options.accessToken,
        serverTimingEnabled: options.serverTimingEnabled,
        instrumentations: options.instrumentations,
        tracerConfig: tracerConfig,
        spanExporterFactory: options.spanExporterFactory,
        spanProcessorFactory: options.spanProcessorFactory,
        propagatorFactory: options.propagatorFactory,
        captureHttpRequestUriParams: options.captureHttpRequestUriParams,
    };
}
exports._setDefaultOptions = _setDefaultOptions;
const SUPPORTED_EXPORTER_TYPES = ['console', 'otlp'];
const SpanExporterMap = {
    console: consoleSpanExporterFactory,
    otlp: otlpSpanExporterFactory,
};
function containsSupportedRealmExporter(exporterTypes) {
    return exporterTypes.includes('otlp');
}
function areValidExporterTypes(types) {
    for (const t of types) {
        if (!SUPPORTED_EXPORTER_TYPES.includes(t)) {
            return false;
        }
    }
    return true;
}
function getExporterTypes(options) {
    const traceExporters = (0, utils_1.getEnvArray)('OTEL_TRACES_EXPORTER', [
        'otlp',
    ]);
    if (options.realm) {
        if (!containsSupportedRealmExporter(traceExporters)) {
            throw new Error('Setting the Splunk realm with an explicit OTEL_TRACES_EXPORTER requires OTEL_TRACES_EXPORTER to be either otlp or be left undefined');
        }
    }
    if (!areValidExporterTypes(traceExporters)) {
        throw new Error(`Invalid value for OTEL_TRACES_EXPORTER env variable: ${util.inspect(process.env.OTEL_TRACES_EXPORTER)}. Choose from ${util.inspect(SUPPORTED_EXPORTER_TYPES, {
            compact: true,
        })} or leave undefined.`);
    }
    return traceExporters;
}
function resolveTraceExporters(exporterTypes) {
    const factories = exporterTypes.map((t) => SpanExporterMap[t]);
    return (options) => factories.flatMap((factory) => factory(options));
}
function otlpSpanExporterFactory(options) {
    var _a;
    let protocol = (0, utils_1.getEnvValueByPrecedence)([
        'OTEL_EXPORTER_OTLP_TRACES_PROTOCOL',
        'OTEL_EXPORTER_OTLP_PROTOCOL',
    ]);
    let endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : (0, utils_1.getEnvValueByPrecedence)([
        'OTEL_EXPORTER_OTLP_TRACES_ENDPOINT',
        'OTEL_EXPORTER_OTLP_ENDPOINT',
    ]);
    const accessToken = options.accessToken;
    if (options.realm !== undefined) {
        if (protocol !== undefined && protocol !== 'http/protobuf') {
            api_1.diag.warn(`OTLP span exporter factory: defaulting protocol to 'http/protobuf' instead of ${protocol} due to realm being defined.`);
        }
        if (endpoint === undefined) {
            endpoint = `https://ingest.${options.realm}.signalfx.com/v2/trace/otlp`;
            protocol = 'http/protobuf';
        }
        else {
            api_1.diag.warn('OTLP span exporter factory: Realm value ignored (full endpoint URL has been specified).');
        }
    }
    protocol = protocol !== null && protocol !== void 0 ? protocol : 'grpc';
    switch (protocol) {
        case 'grpc': {
            const grpcModule = require('@grpc/grpc-js');
            const otlpGrpc = require('@opentelemetry/exporter-trace-otlp-grpc');
            const metadata = new grpcModule.Metadata();
            if (accessToken) {
                // for forward compatibility, is not currently supported
                metadata.set('X-SF-TOKEN', accessToken);
            }
            return new otlpGrpc.OTLPTraceExporter({
                url: endpoint,
                metadata,
            });
        }
        case 'http/protobuf': {
            const headers = accessToken
                ? {
                    'X-SF-TOKEN': accessToken,
                }
                : {};
            return new exporter_trace_otlp_proto_1.OTLPTraceExporter({
                url: endpoint,
                headers,
            });
        }
        default:
            throw new Error(`Expected OTLP protocol to be either grpc or http/protobuf, got ${protocol}.`);
    }
}
exports.otlpSpanExporterFactory = otlpSpanExporterFactory;
function consoleSpanExporterFactory() {
    return new sdk_trace_base_1.ConsoleSpanExporter();
}
exports.consoleSpanExporterFactory = consoleSpanExporterFactory;
// Temporary workaround until https://github.com/open-telemetry/opentelemetry-js/issues/3094 is resolved
function getBatchSpanProcessorConfig() {
    // OTel uses its own parsed environment, we can just use the default env if the BSP delay is unset.
    if ((0, utils_1.getNonEmptyEnvVar)('OTEL_BSP_SCHEDULE_DELAY') !== undefined) {
        return undefined;
    }
    return { scheduledDelayMillis: 500 };
}
function defaultSpanProcessorFactory(options) {
    let exporters = options.spanExporterFactory(options);
    if (!Array.isArray(exporters)) {
        exporters = [exporters];
    }
    return exporters.map((exporter) => new SplunkBatchSpanProcessor_1.SplunkBatchSpanProcessor(exporter, getBatchSpanProcessorConfig()));
}
exports.defaultSpanProcessorFactory = defaultSpanProcessorFactory;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function defaultPropagatorFactory(options) {
    const envPropagators = (0, utils_1.getEnvArray)('OTEL_PROPAGATORS', [
        'tracecontext',
        'baggage',
    ]);
    const propagators = [];
    for (const propagator of envPropagators) {
        switch (propagator) {
            case 'baggage':
                propagators.push(new core_1.W3CBaggagePropagator());
                break;
            case 'tracecontext':
                propagators.push(new core_1.W3CTraceContextPropagator());
                break;
            case 'b3multi':
                propagators.push(new propagator_b3_1.B3Propagator({ injectEncoding: propagator_b3_1.B3InjectEncoding.MULTI_HEADER }));
                break;
            case 'b3':
                propagators.push(new propagator_b3_1.B3Propagator());
                break;
        }
    }
    return new core_1.CompositePropagator({
        propagators,
    });
}
exports.defaultPropagatorFactory = defaultPropagatorFactory;
//# sourceMappingURL=options.js.map