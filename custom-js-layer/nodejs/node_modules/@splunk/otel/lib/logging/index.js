"use strict";
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultlogRecordProcessorFactory = exports._setDefaultOptions = exports.startLogging = exports.allowedLoggingOptions = void 0;
const util = require("util");
const logsAPI = require("@opentelemetry/api-logs");
const exporter_logs_otlp_http_1 = require("@opentelemetry/exporter-logs-otlp-http");
const resources_1 = require("@opentelemetry/resources");
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const utils_1 = require("../utils");
const resource_1 = require("../resource");
exports.allowedLoggingOptions = [
    'accessToken',
    'realm',
    'serviceName',
    'endpoint',
    'logRecordProcessorFactory',
];
function startLogging(opts = {}) {
    const options = _setDefaultOptions(opts);
    const loggerProvider = new sdk_logs_1.LoggerProvider({
        resource: options.resource,
    });
    let processors = options.logRecordProcessorFactory(options);
    if (!Array.isArray(processors)) {
        processors = [processors];
    }
    processors.forEach((processor) => loggerProvider.addLogRecordProcessor(processor));
    logsAPI.logs.setGlobalLoggerProvider(loggerProvider);
    return {
        stop: () => {
            return loggerProvider.shutdown();
        },
    };
}
exports.startLogging = startLogging;
function _setDefaultOptions(options = {}) {
    let resource = (0, resource_1.detect)();
    const serviceName = options.serviceName ||
        (0, utils_1.getNonEmptyEnvVar)('OTEL_SERVICE_NAME') ||
        resource.attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME];
    if (!serviceName) {
        api_1.diag.warn('service.name attribute for logging is not set, your service is unnamed and will be difficult to identify. ' +
            'Set your service name using the OTEL_RESOURCE_ATTRIBUTES environment variable. ' +
            'E.g. OTEL_RESOURCE_ATTRIBUTES="service.name=<YOUR_SERVICE_NAME_HERE>"');
    }
    resource = resource.merge(new resources_1.Resource({
        [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: serviceName || (0, utils_1.defaultServiceName)(),
    }));
    options.logRecordProcessorFactory =
        options.logRecordProcessorFactory || defaultlogRecordProcessorFactory;
    return {
        serviceName: String(resource.attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]),
        endpoint: options.endpoint,
        logRecordProcessorFactory: options.logRecordProcessorFactory,
        resource,
    };
}
exports._setDefaultOptions = _setDefaultOptions;
const SUPPORTED_EXPORTER_TYPES = ['console', 'otlp'];
function areValidExporterTypes(types) {
    return types.every((t) => SUPPORTED_EXPORTER_TYPES.includes(t));
}
function createExporters(options) {
    const logExporters = (0, utils_1.getEnvArray)('OTEL_LOGS_EXPORTER', ['otlp']);
    if (!areValidExporterTypes(logExporters)) {
        throw new Error(`Invalid value for OTEL_LOGS_EXPORTER env variable: ${util.inspect((0, utils_1.getNonEmptyEnvVar)('OTEL_LOGS_EXPORTER'))}. Choose from ${util.inspect(SUPPORTED_EXPORTER_TYPES, {
            compact: true,
        })} or leave undefined.`);
    }
    return logExporters.flatMap((type) => {
        switch (type) {
            case 'otlp':
                return new exporter_logs_otlp_http_1.OTLPLogExporter({
                    url: options.endpoint,
                });
            case 'console':
                return new sdk_logs_1.ConsoleLogRecordExporter();
            default:
                return [];
        }
    });
}
function defaultlogRecordProcessorFactory(options) {
    let exporters = createExporters(options);
    if (!Array.isArray(exporters)) {
        exporters = [exporters];
    }
    return exporters.map((exporter) => new sdk_logs_1.BatchLogRecordProcessor(exporter, {}));
}
exports.defaultlogRecordProcessorFactory = defaultlogRecordProcessorFactory;
//# sourceMappingURL=index.js.map