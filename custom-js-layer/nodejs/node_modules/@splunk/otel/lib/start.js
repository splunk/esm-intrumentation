"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stop = exports.start = void 0;
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const utils_1 = require("./utils");
const metrics_1 = require("./metrics");
const profiling_1 = require("./profiling");
const tracing_1 = require("./tracing");
const options_1 = require("./tracing/options");
const types_1 = require("./profiling/types");
const metrics_2 = require("./metrics");
const api_1 = require("@opentelemetry/api");
const logging_1 = require("./logging");
const running = {
    metrics: null,
    profiling: null,
    tracing: null,
    logging: null,
};
function isSignalEnabled(option, envVar, def) {
    var _a;
    return (_a = option !== null && option !== void 0 ? option : (0, utils_1.parseEnvBooleanString)((0, utils_1.getNonEmptyEnvVar)(envVar))) !== null && _a !== void 0 ? _a : def;
}
const start = (options = {}) => {
    if (running.logging ||
        running.metrics ||
        running.profiling ||
        running.tracing) {
        throw new Error('Splunk APM already started');
    }
    const { metrics, profiling, tracing, logging } = options, restOptions = __rest(options, ["metrics", "profiling", "tracing", "logging"]);
    (0, utils_1.assertNoExtraneousProperties)(restOptions, [
        'accessToken',
        'endpoint',
        'serviceName',
        'logLevel',
    ]);
    const logLevel = options.logLevel
        ? (0, utils_1.toDiagLogLevel)(options.logLevel)
        : (0, utils_1.parseLogLevel)((0, utils_1.getNonEmptyEnvVar)('OTEL_LOG_LEVEL'));
    if (logLevel !== api_1.DiagLogLevel.NONE) {
        api_1.diag.setLogger(new api_1.DiagConsoleLogger(), logLevel);
    }
    let metricsEnabledByDefault = false;
    if (isSignalEnabled(options.profiling, 'SPLUNK_PROFILER_ENABLED', false)) {
        const profilingOptions = Object.assign((0, utils_1.pick)(restOptions, types_1.allowedProfilingOptions), profiling);
        running.profiling = (0, profiling_1.startProfiling)(profilingOptions);
        // HACK: memory profiling needs to enable metrics,
        // run the default option function to see whether memory profiling is enabled
        const materializedOptions = (0, profiling_1._setDefaultOptions)(profilingOptions);
        if (materializedOptions.memoryProfilingEnabled) {
            metricsEnabledByDefault = true;
        }
    }
    if (isSignalEnabled(options.tracing, 'SPLUNK_TRACING_ENABLED', true)) {
        running.tracing = (0, tracing_1.startTracing)(Object.assign((0, utils_1.pick)(restOptions, options_1.allowedTracingOptions), tracing));
    }
    if (isSignalEnabled(options.logging, 'SPLUNK_AUTOMATIC_LOG_COLLECTION', false)) {
        running.logging = (0, logging_1.startLogging)(Object.assign((0, utils_1.pick)(restOptions, logging_1.allowedLoggingOptions), logging));
    }
    if (isSignalEnabled(options.metrics, 'SPLUNK_METRICS_ENABLED', metricsEnabledByDefault)) {
        running.metrics = (0, metrics_1.startMetrics)(Object.assign((0, utils_1.pick)(restOptions, metrics_2.allowedMetricsOptions), metrics));
    }
    const meterProvider = (0, utils_1.getEnvBoolean)('SPLUNK_INSTRUMENTATION_METRICS_ENABLED', false)
        ? api_1.metrics.getMeterProvider()
        : createNoopMeterProvider();
    for (const instrumentation of (0, tracing_1.getLoadedInstrumentations)()) {
        instrumentation.setMeterProvider(meterProvider);
    }
};
exports.start = start;
function createNoopMeterProvider() {
    const meter = (0, api_1.createNoopMeter)();
    return {
        getMeter(_name, _version, _options) {
            return meter;
        },
        // AWS Lambda instrumentation check for the existence of forceFlush,
        // if it does not exist, an error is logged for each span.
        forceFlush() {
            return Promise.resolve();
        },
    };
}
const stop = async () => {
    const promises = [];
    if (running.logging) {
        promises.push(running.logging.stop());
        running.logging = null;
    }
    if (running.metrics) {
        promises.push(running.metrics.stop());
        running.metrics = null;
    }
    if (running.tracing) {
        promises.push((0, tracing_1.stopTracing)());
        running.tracing = null;
    }
    if (running.profiling) {
        promises.push(new Promise((resolve) => {
            running.profiling.stop();
            resolve();
        }));
        running.profiling = null;
    }
    return Promise.all(promises);
};
exports.stop = stop;
//# sourceMappingURL=start.js.map