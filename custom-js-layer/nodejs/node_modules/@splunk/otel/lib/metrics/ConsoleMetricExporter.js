"use strict";
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleMetricExporter = void 0;
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
function logDescriptor(descriptor) {
    const valueType = descriptor.valueType === api_1.ValueType.INT ? 'INT' : 'DOUBLE';
    console.dir(Object.assign(Object.assign({}, descriptor), { valueType }));
}
function logScopeMetrics(scopeMetrics, index) {
    var _a, _b;
    const { scope, metrics } = scopeMetrics;
    console.log(`ScopeMetrics #${index}`);
    console.log(`InstrumentationScope name=${scope.name} version=${scope.version || ''} schemaUrl=${scope.schemaUrl || ''}`);
    for (let i = 0; i < metrics.length; i++) {
        const { descriptor, dataPoints, dataPointType } = metrics[i];
        console.log(`Metric #${i}, descriptor:`);
        logDescriptor(descriptor);
        const dataPointTypeName = dataPointType === sdk_metrics_1.DataPointType.HISTOGRAM
            ? 'HistogramDataPoints'
            : 'NumberDataPoints';
        for (let j = 0; j < dataPoints.length; j++) {
            const dp = dataPoints[j];
            console.log(`${dataPointTypeName} #${j}`);
            console.log(`StartTimestamp ${(0, core_1.hrTimeToTimeStamp)(dp.startTime)}`);
            console.log(`Timestamp ${(0, core_1.hrTimeToTimeStamp)(dp.endTime)}`);
            console.log('Attributes {');
            for (const attributeName of Object.keys(dp.attributes)) {
                const attributeValue = dp.attributes[attributeName];
                console.log(` ${attributeName}: `, attributeValue);
            }
            console.log('}');
            if (dataPointType === sdk_metrics_1.DataPointType.SUM ||
                dataPointType === sdk_metrics_1.DataPointType.GAUGE) {
                const value = dp.value;
                console.log(`Value: ${value.toFixed(6)}`);
            }
            else {
                const value = dp.value;
                const { buckets } = value;
                const { boundaries, counts } = buckets;
                console.log(`Count: ${value.count}`);
                if (value.sum !== undefined) {
                    console.log(`Sum: ${value.sum.toFixed(6)}`);
                }
                if (value.min !== undefined) {
                    console.log(`Min: ${value.min.toFixed(6)}`);
                }
                if (value.max !== undefined) {
                    console.log(`Max: ${value.max.toFixed(6)}`);
                }
                console.log('Bucket counts:');
                for (let boundIdx = -1; boundIdx < boundaries.length; boundIdx++) {
                    const lb = (_a = boundaries[boundIdx]) !== null && _a !== void 0 ? _a : -Infinity;
                    const ub = (_b = boundaries[boundIdx + 1]) !== null && _b !== void 0 ? _b : Infinity;
                    const count = counts[boundIdx + 1];
                    console.log(`  [${lb}, ${ub}) -> ${count}`);
                }
            }
        }
    }
}
class ConsoleMetricExporter {
    constructor(options = {}) {
        var _a;
        this._aggregationTemporality =
            (_a = options.temporalityPreference) !== null && _a !== void 0 ? _a : sdk_metrics_1.AggregationTemporality.CUMULATIVE;
    }
    export(metrics, resultCallback) {
        console.log('Resource metrics:');
        console.dir(metrics.resource);
        for (let i = 0; i < metrics.scopeMetrics.length; i++) {
            logScopeMetrics(metrics.scopeMetrics[i], i);
        }
        resultCallback({
            code: core_1.ExportResultCode.SUCCESS,
        });
    }
    selectAggregationTemporality(_instrumentType) {
        return this._aggregationTemporality;
    }
    async forceFlush() { }
    async shutdown() { }
}
exports.ConsoleMetricExporter = ConsoleMetricExporter;
//# sourceMappingURL=ConsoleMetricExporter.js.map