"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OTLPProfilingExporter = void 0;
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const protoLoader = require("@grpc/proto-loader");
const path = require("path");
const api_1 = require("@opentelemetry/api");
const resources_1 = require("@opentelemetry/resources");
const core_1 = require("@opentelemetry/core");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const utils_1 = require("./utils");
const OTEL_PROFILING_VERSION = '0.1.0';
function commonAttributes(profilingType, sampleCount) {
    return [
        {
            key: 'profiling.data.format',
            value: { stringValue: 'pprof-gzip-base64' },
        },
        {
            key: 'profiling.data.type',
            value: { stringValue: profilingType },
        },
        {
            key: 'com.splunk.sourcetype',
            value: { stringValue: 'otel.profiling' },
        },
        {
            key: 'profiling.data.total.frame.count',
            value: { intValue: sampleCount },
        },
    ];
}
function countSamples(stacktraces) {
    let sampleCount = 0;
    for (const profilingStacktrace of stacktraces) {
        sampleCount += profilingStacktrace.stacktrace.length;
    }
    return sampleCount;
}
class OTLPProfilingExporter {
    constructor(options) {
        this._options = options;
        const protosDir = path.resolve(__dirname, '..', '..', 'protos');
        const packageDef = protoLoader.loadSync(path.join(protosDir, 'opentelemetry/proto/collector/logs/v1/logs_service.proto'), {
            keepCase: false,
            longs: String,
            enums: String,
            defaults: true,
            oneofs: true,
            includeDirs: [protosDir],
        });
        this._grpc = require('@grpc/grpc-js');
        const { host, credentials } = (0, utils_1.parseEndpoint)(options.endpoint, this._grpc);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const packageObject = this._grpc.loadPackageDefinition(packageDef);
        this._client =
            new packageObject.opentelemetry.proto.collector.logs.v1.LogsService(host, credentials);
        const resource = new resources_1.Resource({
            [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: 'node',
            [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: core_1.VERSION,
        }).merge(options.resource);
        this._resourceAttributes = [];
        for (const key in resource.attributes) {
            const value = resource.attributes[key];
            if (typeof value === 'string') {
                this._resourceAttributes.push({
                    key,
                    value: { stringValue: value },
                });
            }
            else if (typeof value === 'number') {
                if (Number.isInteger(value)) {
                    this._resourceAttributes.push({
                        key,
                        value: { intValue: value },
                    });
                }
                else {
                    this._resourceAttributes.push({
                        key,
                        value: { doubleValue: value },
                    });
                }
            }
            else {
                this._resourceAttributes.push({
                    key,
                    value: { boolValue: value },
                });
            }
        }
    }
    send(profile) {
        const { stacktraces } = profile;
        const sampleCount = countSamples(stacktraces);
        api_1.diag.debug(`profiling: Exporting ${sampleCount} CPU samples`);
        const { callstackInterval } = this._options;
        const attributes = commonAttributes('cpu', sampleCount);
        (0, utils_1.encode)((0, utils_1.serialize)(profile, { samplingPeriodMillis: callstackInterval }))
            .then((serializedProfile) => {
            const logs = [serializedProfile].map((st) => {
                return {
                    name: 'otel.profiling',
                    body: { stringValue: st.toString('base64') },
                    attributes,
                };
            });
            const ilLogs = {
                instrumentationLibrary: {
                    name: 'otel.profiling',
                    version: OTEL_PROFILING_VERSION,
                },
                logs,
            };
            const resourceLogs = [
                {
                    resource: {
                        attributes: this._resourceAttributes,
                    },
                    instrumentationLibraryLogs: [ilLogs],
                },
            ];
            const payload = {
                resourceLogs,
            };
            this._client.export(payload, new this._grpc.Metadata(), (err) => {
                if (err) {
                    api_1.diag.error('Error exporting profiling data', err);
                }
            });
        })
            .catch((err) => {
            api_1.diag.error('Error exporting profiling data', err);
        });
    }
    sendHeapProfile(profile) {
        const serialized = (0, utils_1.serializeHeapProfile)(profile);
        const sampleCount = profile.samples.length;
        const attributes = commonAttributes('allocation', sampleCount);
        api_1.diag.debug(`profiling: Exporting ${sampleCount} heap samples`);
        (0, utils_1.encode)(serialized)
            .then((serializedProfile) => {
            const logs = [serializedProfile].map((st) => {
                return {
                    name: 'otel.profiling',
                    body: { stringValue: st.toString('base64') },
                    attributes,
                };
            });
            const ilLogs = {
                instrumentationLibrary: {
                    name: 'otel.profiling',
                    version: OTEL_PROFILING_VERSION,
                },
                logs,
            };
            const resourceLogs = [
                {
                    resource: {
                        attributes: this._resourceAttributes,
                    },
                    instrumentationLibraryLogs: [ilLogs],
                },
            ];
            const payload = {
                resourceLogs,
            };
            this._client.export(payload, new this._grpc.Metadata(), (err) => {
                if (err) {
                    api_1.diag.error('Error exporting profiling data', err);
                }
            });
        })
            .catch((err) => {
            api_1.diag.error('Error exporting profiling data', err);
        });
    }
}
exports.OTLPProfilingExporter = OTLPProfilingExporter;
//# sourceMappingURL=OTLPProfilingExporter.js.map