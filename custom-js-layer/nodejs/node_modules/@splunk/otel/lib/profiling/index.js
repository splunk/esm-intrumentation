"use strict";
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports._setDefaultOptions = exports.loadExtension = exports.startProfiling = exports.isProfilingContextManagerSet = exports.defaultExporterFactory = void 0;
const api_1 = require("@opentelemetry/api");
const resources_1 = require("@opentelemetry/resources");
const utils_1 = require("../utils");
const debug_metrics_1 = require("../metrics/debug_metrics");
const resource_1 = require("../resource");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const types_1 = require("./types");
const ProfilingContextManager_1 = require("./ProfilingContextManager");
const OTLPProfilingExporter_1 = require("./OTLPProfilingExporter");
const tracing_1 = require("../tracing");
/* The following are wrappers around native functions to give more context to profiling samples. */
function extStopProfiling(extension) {
    api_1.diag.debug('profiling: Stopping');
    return extension.stop();
}
function extStopMemoryProfiling(extension) {
    return extension.stopMemoryProfiling();
}
function extStartProfiling(extension, opts) {
    api_1.diag.debug('profiling: Starting');
    extension.start(opts);
}
function extStartMemoryProfiling(extension, options) {
    return extension.startMemoryProfiling(options);
}
function extCollectHeapProfile(extension) {
    return extension.collectHeapProfile();
}
function extCollectCpuProfile(extension) {
    api_1.diag.debug('profiling: Collecting CPU profile');
    return extension.collect();
}
function defaultExporterFactory(options) {
    const exporters = [
        new OTLPProfilingExporter_1.OTLPProfilingExporter({
            endpoint: options.endpoint,
            callstackInterval: options.callstackInterval,
            resource: options.resource,
        }),
    ];
    return exporters;
}
exports.defaultExporterFactory = defaultExporterFactory;
let profilingContextManagerEnabled = false;
function isProfilingContextManagerSet() {
    return profilingContextManagerEnabled;
}
exports.isProfilingContextManagerSet = isProfilingContextManagerSet;
function startProfiling(opts = {}) {
    (0, utils_1.assertNoExtraneousProperties)(opts, types_1.allowedProfilingOptions);
    const options = _setDefaultOptions(opts);
    const extension = loadExtension();
    if (extension === undefined) {
        return {
            stop: () => { },
        };
    }
    if ((0, tracing_1.isTracingContextManagerEnabled)()) {
        api_1.diag.warn(`Splunk profiling: unable to set up context manager due to tracing's context manager being active. Traces won't be correlated to profiling data. Please start profiling before tracing.`);
    }
    else if (!profilingContextManagerEnabled) {
        const contextManager = new ProfilingContextManager_1.ProfilingContextManager();
        contextManager.enable();
        api_1.context.setGlobalContextManager(contextManager);
        profilingContextManagerEnabled = true;
    }
    const samplingIntervalMicroseconds = options.callstackInterval * 1000;
    const startOptions = {
        samplingIntervalMicroseconds,
        maxSampleCutoffDelayMicroseconds: samplingIntervalMicroseconds / 2,
        recordDebugInfo: false,
    };
    extStartProfiling(extension, startOptions);
    let cpuSamplesCollectInterval;
    let memSamplesCollectInterval;
    let exporters = [];
    // Tracing needs to be started after profiling, setting up the profiling exporter
    // causes @grpc/grpc-js to be loaded, but to avoid any loads before tracing's setup
    // has finished, load it next event loop.
    setImmediate(() => {
        exporters = options.exporterFactory(options);
        cpuSamplesCollectInterval = setInterval(() => {
            const cpuProfile = extCollectCpuProfile(extension);
            if (cpuProfile) {
                (0, debug_metrics_1.recordCpuProfilerMetrics)(cpuProfile);
                for (const exporter of exporters) {
                    exporter.send(cpuProfile);
                }
            }
        }, options.collectionDuration);
        cpuSamplesCollectInterval.unref();
        if (options.memoryProfilingEnabled) {
            extStartMemoryProfiling(extension, options.memoryProfilingOptions);
            memSamplesCollectInterval = setInterval(() => {
                const heapProfile = extCollectHeapProfile(extension);
                if (heapProfile) {
                    (0, debug_metrics_1.recordHeapProfilerMetrics)(heapProfile);
                    for (const exporter of exporters) {
                        exporter.sendHeapProfile(heapProfile);
                    }
                }
            }, options.collectionDuration);
            memSamplesCollectInterval.unref();
        }
    });
    return {
        stop: () => {
            if (options.memoryProfilingEnabled) {
                clearInterval(memSamplesCollectInterval);
                extStopMemoryProfiling(extension);
            }
            clearInterval(cpuSamplesCollectInterval);
            const cpuProfile = extStopProfiling(extension);
            if (cpuProfile) {
                for (const exporter of exporters) {
                    exporter.send(cpuProfile);
                }
            }
        },
    };
}
exports.startProfiling = startProfiling;
function loadExtension() {
    try {
        api_1.diag.debug('profiling: Loading');
        return require('../native_ext').profiling;
    }
    catch (e) {
        api_1.diag.error('profiling: Unable to load extension. Profiling data will not be reported', e);
    }
    return undefined;
}
exports.loadExtension = loadExtension;
function _setDefaultOptions(options = {}) {
    var _a, _b;
    const endpoint = options.endpoint ||
        (0, utils_1.getNonEmptyEnvVar)('SPLUNK_PROFILER_LOGS_ENDPOINT') ||
        (0, utils_1.getNonEmptyEnvVar)('OTEL_EXPORTER_OTLP_ENDPOINT') ||
        'http://localhost:4317';
    const combinedResource = (0, resource_1.detect)();
    const serviceName = String(options.serviceName ||
        (0, utils_1.getNonEmptyEnvVar)('OTEL_SERVICE_NAME') ||
        combinedResource.attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME] ||
        (0, utils_1.defaultServiceName)());
    let resource = options.resource === undefined
        ? combinedResource
        : combinedResource.merge(options.resource);
    resource = resource.merge(new resources_1.Resource({
        [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: serviceName,
    }));
    const memoryProfilingEnabled = (_a = options.memoryProfilingEnabled) !== null && _a !== void 0 ? _a : (0, utils_1.getEnvBoolean)('SPLUNK_PROFILER_MEMORY_ENABLED', false);
    return {
        serviceName: serviceName,
        endpoint,
        callstackInterval: options.callstackInterval ||
            (0, utils_1.getEnvNumber)('SPLUNK_PROFILER_CALL_STACK_INTERVAL', 1000),
        collectionDuration: options.collectionDuration || 30000,
        resource,
        exporterFactory: (_b = options.exporterFactory) !== null && _b !== void 0 ? _b : defaultExporterFactory,
        memoryProfilingEnabled,
        memoryProfilingOptions: options.memoryProfilingOptions,
    };
}
exports._setDefaultOptions = _setDefaultOptions;
//# sourceMappingURL=index.js.map